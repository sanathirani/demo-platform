const twilio = require('twilio');
const nodemailer = require('nodemailer');
const { config } = require('../config/config');
const { logger, logAlert } = require('../utils/logger');
const { formatTimeForAlert } = require('../utils/timeUtils');

// Initialize Twilio client
let twilioClient = null;

function getTwilioClient() {
  if (!twilioClient) {
    twilioClient = twilio(config.twilio.accountSid, config.twilio.authToken);
  }
  return twilioClient;
}

// Initialize Nodemailer transporter
let emailTransporter = null;

function getEmailTransporter() {
  if (!emailTransporter) {
    emailTransporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: config.email.user,
        pass: config.email.appPassword,
      },
    });
  }
  return emailTransporter;
}

/**
 * Send WhatsApp message via Twilio
 * @param {string} message - Message to send
 * @returns {Promise<Object>} Twilio response
 */
async function sendWhatsApp(message) {
  try {
    const client = getTwilioClient();
    const result = await client.messages.create({
      body: message,
      from: config.twilio.whatsappFrom,
      to: `whatsapp:${config.alerts.phone}`,
    });
    logAlert('WHATSAPP', true, message);
    return result;
  } catch (error) {
    logAlert('WHATSAPP', false, error.message);
    logger.error('WhatsApp send failed', { error: error.message });
    throw error;
  }
}

/**
 * Send SMS via Twilio
 * @param {string} message - Message to send
 * @returns {Promise<Object>} Twilio response
 */
async function sendSMS(message) {
  try {
    const client = getTwilioClient();
    const result = await client.messages.create({
      body: message,
      from: config.twilio.smsFrom,
      to: config.alerts.phone,
    });
    logAlert('SMS', true, message);
    return result;
  } catch (error) {
    logAlert('SMS', false, error.message);
    logger.error('SMS send failed', { error: error.message });
    throw error;
  }
}

/**
 * Send email via Nodemailer
 * @param {string} subject - Email subject
 * @param {string} body - Email body (HTML supported)
 * @returns {Promise<Object>} Nodemailer response
 */
async function sendEmail(subject, body) {
  try {
    const transporter = getEmailTransporter();
    const result = await transporter.sendMail({
      from: config.email.user,
      to: config.alerts.email,
      subject: subject,
      html: body,
      text: body.replace(/<[^>]*>/g, ''), // Strip HTML for plain text
    });
    logAlert('EMAIL', true, subject);
    return result;
  } catch (error) {
    logAlert('EMAIL', false, error.message);
    logger.error('Email send failed', { error: error.message });
    throw error;
  }
}

/**
 * Format signal into alert message
 * @param {Object} signal - Trading signal object
 * @returns {string} Formatted message
 */
function formatAlertMessage(signal) {
  const {
    strategy,
    direction,
    strike,
    premium,
    stopLoss,
    spotPrice,
    time,
    isCDaySignal,
  } = signal;

  const targetPremium = Math.round(premium * 2);
  const maxRisk = config.trading.maxLossPerTrade.toLocaleString('en-IN');

  // C-Day signal warning
  const header = isCDaySignal
    ? `‚ö†Ô∏è C-DAY SIGNAL ‚ö†Ô∏è

üî¨ FORCE ANALYZE MODE
Previous day was NOT an A-Day.
Trade with extra caution.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`
    : `üö® A-DAY SIGNAL üö®`;

  return `${header}

Setup: ${strategy}
Direction: NIFTY ${direction}

Strike: ${strike}
Premium: Rs ${premium}
Spot: ${spotPrice}
Time: ${formatTimeForAlert(time || new Date())}

Stop Loss: Spot ${direction === 'BUY_CE' ? 'below' : 'above'} ${stopLoss}
Target: 2x Risk (Rs ${targetPremium})
Max Risk: Rs ${maxRisk}

---
Auto-generated by A-Day Alert System`;
}

/**
 * Format signal into HTML email
 * @param {Object} signal - Trading signal object
 * @returns {string} HTML formatted email
 */
function formatEmailBody(signal) {
  const {
    strategy,
    direction,
    strike,
    premium,
    stopLoss,
    spotPrice,
    time,
    isCDaySignal,
  } = signal;

  const targetPremium = Math.round(premium * 2);
  const maxRisk = config.trading.maxLossPerTrade.toLocaleString('en-IN');

  // C-Day warning banner
  const cdayBanner = isCDaySignal ? `
  <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0;">
    <strong>üî¨ FORCE ANALYZE MODE - C-DAY SIGNAL</strong><br/>
    Previous day was NOT an A-Day.<br/>
    <strong>Trade with extra caution.</strong>
  </div>
  ` : '';

  const headerColor = isCDaySignal ? '#ff9800' : '#1a73e8';
  const headerText = isCDaySignal ? '‚ö†Ô∏è C-DAY SIGNAL' : 'üö® A-DAY SIGNAL';

  return `
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; }
    .header { background: ${headerColor}; color: white; padding: 20px; text-align: center; }
    .content { padding: 20px; }
    .signal-box { background: #f5f5f5; border-left: 4px solid #1a73e8; padding: 15px; margin: 15px 0; }
    .label { color: #666; font-size: 12px; text-transform: uppercase; }
    .value { font-size: 18px; font-weight: bold; color: #333; }
    .risk { background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 15px 0; }
    .footer { text-align: center; color: #999; font-size: 12px; padding: 20px; border-top: 1px solid #eee; }
  </style>
</head>
<body>
  <div class="header">
    <h1>${headerText}</h1>
  </div>
  <div class="content">
    ${cdayBanner}
    <div class="signal-box">
      <div class="label">Setup</div>
      <div class="value">${strategy}</div>
    </div>
    <div class="signal-box">
      <div class="label">Direction</div>
      <div class="value">NIFTY ${direction}</div>
    </div>
    <div class="signal-box">
      <div class="label">Strike</div>
      <div class="value">${strike}</div>
    </div>
    <div class="signal-box">
      <div class="label">Premium</div>
      <div class="value">Rs ${premium}</div>
    </div>
    <div class="signal-box">
      <div class="label">Spot Price</div>
      <div class="value">${spotPrice}</div>
    </div>
    <div class="signal-box">
      <div class="label">Time</div>
      <div class="value">${formatTimeForAlert(time || new Date())}</div>
    </div>
    <div class="risk">
      <div class="label">Stop Loss</div>
      <div class="value">Spot ${direction === 'BUY_CE' ? 'below' : 'above'} ${stopLoss}</div>
    </div>
    <div class="risk">
      <div class="label">Target</div>
      <div class="value">2x Risk (Rs ${targetPremium})</div>
    </div>
    <div class="risk">
      <div class="label">Max Risk</div>
      <div class="value">Rs ${maxRisk}</div>
    </div>
  </div>
  <div class="footer">
    Auto-generated by A-Day Alert System
  </div>
</body>
</html>`;
}

/**
 * Send alert through all channels (WhatsApp, Email, SMS)
 * @param {Object} signal - Trading signal object
 * @returns {Promise<Object>} Results from all channels
 */
async function sendAlert(signal) {
  const message = formatAlertMessage(signal);
  const emailBody = formatEmailBody(signal);
  const emailSubject = signal.isCDaySignal
    ? `‚ö†Ô∏è C-DAY SIGNAL: ${signal.strategy} - ${signal.direction}`
    : `üö® A-DAY SIGNAL: ${signal.strategy} - ${signal.direction}`;

  const results = {
    whatsapp: null,
    email: null,
    sms: null,
    errors: [],
  };

  // Send all alerts in parallel
  const promises = [
    sendWhatsApp(message)
      .then(r => { results.whatsapp = r; })
      .catch(e => { results.errors.push({ channel: 'whatsapp', error: e.message }); }),
    sendEmail(emailSubject, emailBody)
      .then(r => { results.email = r; })
      .catch(e => { results.errors.push({ channel: 'email', error: e.message }); }),
    sendSMS(message)
      .then(r => { results.sms = r; })
      .catch(e => { results.errors.push({ channel: 'sms', error: e.message }); }),
  ];

  await Promise.all(promises);

  const successCount = [results.whatsapp, results.email, results.sms].filter(Boolean).length;
  logger.info('Alert sent', {
    strategy: signal.strategy,
    direction: signal.direction,
    successCount,
    errors: results.errors,
  });

  return results;
}

/**
 * Send a test alert
 * @returns {Promise<Object>} Results from all channels
 */
async function sendTestAlert() {
  const testSignal = {
    strategy: 'TEST ALERT',
    direction: 'BUY_CE',
    strike: '22800 CE',
    premium: 100,
    stopLoss: 22500,
    spotPrice: 22750,
    time: new Date(),
  };

  logger.info('Sending test alert');
  return sendAlert(testSignal);
}

module.exports = {
  sendWhatsApp,
  sendSMS,
  sendEmail,
  sendAlert,
  sendTestAlert,
  formatAlertMessage,
};
